<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Methods · IntervalMatrices.jl</title><meta name="title" content="Methods · IntervalMatrices.jl"/><meta property="og:title" content="Methods · IntervalMatrices.jl"/><meta property="twitter:title" content="Methods · IntervalMatrices.jl"/><meta name="description" content="Documentation for IntervalMatrices.jl."/><meta property="og:description" content="Documentation for IntervalMatrices.jl."/><meta property="twitter:description" content="Documentation for IntervalMatrices.jl."/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/aligned.css" rel="stylesheet" type="text/css"/><link href="../../assets/citations.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="IntervalMatrices.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">IntervalMatrices.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../types/">Types</a></li><li class="is-active"><a class="tocitem" href>Methods</a><ul class="internal"><li><a class="tocitem" href="#Common-functions"><span>Common functions</span></a></li><li><a class="tocitem" href="#Arithmetic"><span>Arithmetic</span></a></li><li><a class="tocitem" href="#Matrix-power"><span>Matrix power</span></a></li><li><a class="tocitem" href="#Matrix-exponential"><span>Matrix exponential</span></a></li><li><a class="tocitem" href="#Finite-expansions"><span>Finite expansions</span></a></li><li><a class="tocitem" href="#Correction-terms"><span>Correction terms</span></a></li><li><a class="tocitem" href="#Norms"><span>Norms</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../about/">About</a></li><li><a class="tocitem" href="../../bibliography/">Bibliography</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li class="is-active"><a href>Methods</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Methods</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/JuliaReach/IntervalMatrices.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/master/docs/src/lib/methods.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Methods"><a class="docs-heading-anchor" href="#Methods">Methods</a><a id="Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Methods" title="Permalink"></a></h1><p>This section describes systems methods implemented in <code>IntervalMatrices.jl</code>.</p><ul><li><a href="#Methods">Methods</a></li><li class="no-marker"><ul><li><a href="#Common-functions">Common functions</a></li><li><a href="#Arithmetic">Arithmetic</a></li><li><a href="#Matrix-power">Matrix power</a></li><li><a href="#Matrix-exponential">Matrix exponential</a></li><li class="no-marker"><ul><li><a href="#Algorithms">Algorithms</a></li><li><a href="#Implementations">Implementations</a></li></ul></li><li><a href="#Finite-expansions">Finite expansions</a></li><li><a href="#Correction-terms">Correction terms</a></li><li><a href="#Norms">Norms</a></li></ul></li></ul><h2 id="Common-functions"><a class="docs-heading-anchor" href="#Common-functions">Common functions</a><a id="Common-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Common-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntervalArithmetic.inf" href="#IntervalArithmetic.inf"><code>IntervalArithmetic.inf</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">inf(A::IntervalMatrix{T}) where {T}</code></pre><p>Return the infimum of an interval matrix <code>A</code>, which corresponds to taking the element-wise infimum of <code>A</code>.</p><p><strong>Input</strong></p><ul><li><code>A</code> – interval matrix</li></ul><p><strong>Output</strong></p><p>A scalar matrix whose coefficients are the infima of each element in <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/337c0558eaef739dd15e78b47f3aecd65c1c69a1/src/operations/numops.jl#L1-L14">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntervalArithmetic.sup" href="#IntervalArithmetic.sup"><code>IntervalArithmetic.sup</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sup(A::IntervalMatrix{T}) where {T}</code></pre><p>Return the supremum of an interval matrix <code>A</code>, which corresponds to taking the element-wise supremum of <code>A</code>.</p><p><strong>Input</strong></p><ul><li><code>A</code> – interval matrix</li></ul><p><strong>Output</strong></p><p>A scalar matrix whose coefficients are the suprema of each element in <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/337c0558eaef739dd15e78b47f3aecd65c1c69a1/src/operations/numops.jl#L19-L32">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntervalArithmetic.mid" href="#IntervalArithmetic.mid"><code>IntervalArithmetic.mid</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mid(A::IntervalMatrix{T}) where {T}</code></pre><p>Return the midpoint of an interval matrix <code>A</code>, which corresponds to taking the element-wise midpoint of <code>A</code>.</p><p><strong>Input</strong></p><ul><li><code>A</code> – interval matrix</li></ul><p><strong>Output</strong></p><p>A scalar matrix whose coefficients are the midpoints of each element in <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/337c0558eaef739dd15e78b47f3aecd65c1c69a1/src/operations/numops.jl#L37-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntervalArithmetic.diam" href="#IntervalArithmetic.diam"><code>IntervalArithmetic.diam</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">diam(A::IntervalMatrix{T}) where {T}</code></pre><p>Return a matrix whose entries describe the diameters of the intervals.</p><p><strong>Input</strong></p><ul><li><code>A</code> – interval matrix</li></ul><p><strong>Output</strong></p><p>A matrix <code>B</code> of the same shape as <code>A</code> such that <code>B[i, j] == diam(A[i, j])</code> for each <code>i</code> and <code>j</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/337c0558eaef739dd15e78b47f3aecd65c1c69a1/src/operations/numops.jl#L73-L86">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntervalArithmetic.radius" href="#IntervalArithmetic.radius"><code>IntervalArithmetic.radius</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">radius(A::IntervalMatrix{T}) where {T}</code></pre><p>Return the radius of an interval matrix <code>A</code>, which corresponds to taking the element-wise radius of <code>A</code>.</p><p><strong>Input</strong></p><ul><li><code>A</code> – interval matrix</li></ul><p><strong>Output</strong></p><p>A scalar matrix whose coefficients are the radii of each element in <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/337c0558eaef739dd15e78b47f3aecd65c1c69a1/src/operations/numops.jl#L55-L68">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntervalArithmetic.midpoint_radius" href="#IntervalArithmetic.midpoint_radius"><code>IntervalArithmetic.midpoint_radius</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">midpoint_radius(A::IntervalMatrix{T}) where {T}</code></pre><p>Split an interval matrix <span>$A$</span> into two scalar matrices <span>$C$</span> and <span>$S$</span> such that <span>$A = C + [-S, S]$</span>.</p><p><strong>Input</strong></p><ul><li><code>A</code> – interval matrix</li></ul><p><strong>Output</strong></p><p>A pair <code>(C, S)</code> such that the entries of <code>C</code> are the central points and the entries of <code>S</code> are the (nonnegative) radii of the intervals in <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/337c0558eaef739dd15e78b47f3aecd65c1c69a1/src/operations/numops.jl#L91-L105">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.rand" href="#Base.rand"><code>Base.rand</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rand(::Type{IntervalMatrix}, m::Int=2, [n]::Int=m;
     N=Float64, rng::AbstractRNG=GLOBAL_RNG)</code></pre><p>Return a random interval matrix of the given size and numeric type.</p><p><strong>Input</strong></p><ul><li><code>IntervalMatrix</code> – type, used for dispatch</li><li><code>m</code>              – (optional, default: <code>2</code>) number of rows</li><li><code>n</code>              – (optional, default: <code>m</code>) number of columns</li><li><code>rng</code>            – (optional, default: <code>GLOBAL_RNG</code>) random-number generator</li></ul><p><strong>Output</strong></p><p>An interval matrix of size <span>$m × n$</span> whose coefficients are normally-distributed intervals of type <code>N</code> with mean <code>0</code> and standard deviation <code>1</code>.</p><p><strong>Notes</strong></p><p>If this function is called with only one argument, it creates a square matrix, because the number of columns defaults to the number of rows.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/337c0558eaef739dd15e78b47f3aecd65c1c69a1/src/operations/random.jl#L7-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntervalMatrices.sample" href="#IntervalMatrices.sample"><code>IntervalMatrices.sample</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">sample(A::IntervalMatrix{T}; rng::AbstractRNG=GLOBAL_RNG) where {T}</code></pre><p>Return a sample of the given random interval matrix.</p><p><strong>Input</strong></p><ul><li><code>A</code>   – interval matrix</li><li><code>m</code>   – (optional, default: <code>2</code>) number of rows</li><li><code>n</code>   – (optional, default: <code>2</code>) number of columns</li><li><code>rng</code> – (optional, default: <code>GLOBAL_RNG</code>) random-number generator</li></ul><p><strong>Output</strong></p><p>An interval matrix of size <span>$m × n$</span> whose coefficients are normally-distributed intervals of type <code>N</code> with mean <code>0</code> and standard deviation <code>1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/337c0558eaef739dd15e78b47f3aecd65c1c69a1/src/operations/random.jl#L43-L59">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:∈" href="#Base.:∈"><code>Base.:∈</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">∈(M::AbstractMatrix, A::AbstractIntervalMatrix)</code></pre><p>Check whether a concrete matrix is an instance of an interval matrix.</p><p><strong>Input</strong></p><ul><li><code>M</code> – concrete matrix</li><li><code>A</code> – interval matrix</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <code>M</code> is an instance of <code>A</code></p><p><strong>Algorithm</strong></p><p>We check for each entry in <code>M</code> whether it belongs to the corresponding interval in <code>A</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/337c0558eaef739dd15e78b47f3aecd65c1c69a1/src/operations/setops.jl#L1-L19">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntervalArithmetic.:±" href="#IntervalArithmetic.:±"><code>IntervalArithmetic.:±</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">±(C::MT, S::MT) where {T, MT&lt;:AbstractMatrix{T}}</code></pre><p>Return an interval matrix such that the center and radius of the intervals is given by the matrices <code>C</code> and <code>S</code> respectively.</p><p><strong>Input</strong></p><ul><li><code>C</code> – center matrix</li><li><code>S</code> – radii matrix</li></ul><p><strong>Output</strong></p><p>An interval matrix <code>M</code> such that <code>M[i, j]</code> corresponds to the interval whose center is <code>C[i, j]</code> and whose radius is <code>S[i, j]</code>, for each <code>i</code> and <code>j</code>. That is, <span>$M = C + [-S, S]$</span>.</p><p><strong>Notes</strong></p><p>The radii matrix should be nonnegative, i.e. <code>S[i, j] ≥ 0</code> for each <code>i</code> and <code>j</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; [1 2; 3 4] ± [1 2; 4 5]
2×2 IntervalMatrix{Float64, Interval{Float64}, Matrix{Interval{Float64}}}:
  [0.0, 2.0]   [0.0, 4.0]
 [-1.0, 7.0]  [-1.0, 9.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/337c0558eaef739dd15e78b47f3aecd65c1c69a1/src/matrix.jl#L144-L173">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:⊆" href="#Base.:⊆"><code>Base.:⊆</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">⊆(A::AbstractIntervalMatrix, B::AbstractIntervalMatrix)</code></pre><p>Check whether an interval matrix is contained in another interval matrix.</p><p><strong>Input</strong></p><ul><li><code>A</code> – interval matrix</li><li><code>B</code> – interval matrix</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <code>A[i, j] ⊆ B[i, j]</code> for all <code>i, j</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/337c0558eaef739dd15e78b47f3aecd65c1c69a1/src/operations/setops.jl#L35-L48">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:∩" href="#Base.:∩"><code>Base.:∩</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">∩(A::IntervalMatrix, B::IntervalMatrix)</code></pre><p>Intersect two interval matrices.</p><p><strong>Input</strong></p><ul><li><code>A</code> – interval matrix</li><li><code>B</code> – interval matrix (of the same shape as <code>A</code>)</li></ul><p><strong>Output</strong></p><p>A new matrix <code>C</code> of the same shape as <code>A</code> such that <code>C[i, j] = A[i, j] ∩ B[i, j]</code> for each <code>i</code> and <code>j</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/337c0558eaef739dd15e78b47f3aecd65c1c69a1/src/operations/setops.jl#L62-L76">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="Base.:∪" href="#Base.:∪"><code>Base.:∪</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">∪(A::IntervalMatrix, B::IntervalMatrix)</code></pre><p>Finds the interval union (hull) of two interval matrices. This is equivalent to <a href="#IntervalArithmetic.hull"><code>hull</code></a>.</p><p><strong>Input</strong></p><ul><li><code>A</code> – interval matrix</li><li><code>B</code> – interval matrix (of the same shape as <code>A</code>)</li></ul><p><strong>Output</strong></p><p>A new matrix <code>C</code> of the same shape as <code>A</code> such that <code>C[i, j] = A[i, j] ∪ B[i, j]</code> for each <code>i</code> and <code>j</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/337c0558eaef739dd15e78b47f3aecd65c1c69a1/src/operations/setops.jl#L106-L121">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntervalArithmetic.hull" href="#IntervalArithmetic.hull"><code>IntervalArithmetic.hull</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hull(A::IntervalMatrix, B::IntervalMatrix)</code></pre><p>Finds the interval hull of two interval matrices. This is equivalent to <a href="#Base.:∪"><code>∪</code></a>.</p><p><strong>Input</strong></p><ul><li><code>A</code> – interval matrix</li><li><code>B</code> – interval matrix (of the same shape as <code>A</code>)</li></ul><p><strong>Output</strong></p><p>A new matrix <code>C</code> of the same shape as <code>A</code> such that <code>C[i, j] = hull(A[i, j], B[i, j])</code> for each <code>i</code> and <code>j</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/337c0558eaef739dd15e78b47f3aecd65c1c69a1/src/operations/setops.jl#L84-L98">source</a></section></article><h2 id="Arithmetic"><a class="docs-heading-anchor" href="#Arithmetic">Arithmetic</a><a id="Arithmetic-1"></a><a class="docs-heading-anchor-permalink" href="#Arithmetic" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntervalMatrices.square" href="#IntervalMatrices.square"><code>IntervalMatrices.square</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">square(A::IntervalMatrix)</code></pre><p>Compute the square of an interval matrix.</p><p><strong>Input</strong></p><ul><li><code>A</code> – interval matrix</li></ul><p><strong>Output</strong></p><p>An interval matrix equivalent to <code>A * A</code>.</p><p><strong>Algorithm</strong></p><p>We follow <a href="../../bibliography/#KoshelevaKMN05">Kosheleva <em>et al.</em> [KKMN05]</a>, Section 6.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/337c0558eaef739dd15e78b47f3aecd65c1c69a1/src/operations/arithmetic.jl#L63-L79">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntervalMatrices.scale" href="#IntervalMatrices.scale"><code>IntervalMatrices.scale</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">scale(A::IntervalMatrix{T}, α::T) where {T}</code></pre><p>Return a new interval matrix whose entries are scaled by the given factor.</p><p><strong>Input</strong></p><ul><li><code>A</code> – interval matrix</li><li><code>α</code> – scaling factor</li></ul><p><strong>Output</strong></p><p>A new matrix <code>B</code> of the same shape as <code>A</code> such that <code>B[i, j] = α*A[i, j]</code> for each <code>i</code> and <code>j</code>.</p><p><strong>Notes</strong></p><p>See <code>scale!</code> for the in-place version of this function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/337c0558eaef739dd15e78b47f3aecd65c1c69a1/src/operations/arithmetic.jl#L107-L125">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntervalMatrices.scale!" href="#IntervalMatrices.scale!"><code>IntervalMatrices.scale!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">scale!(A::IntervalMatrix{T}, α::T) where {T}</code></pre><p>Modifies the given interval matrix, scaling its entries by the given factor.</p><p><strong>Input</strong></p><ul><li><code>A</code> – interval matrix</li><li><code>α</code> – scaling factor</li></ul><p><strong>Output</strong></p><p>The matrix <code>A</code> such that for each <code>i</code> and <code>j</code>, the new value of <code>A[i, j]</code> is <code>α*A[i, j]</code>.</p><p><strong>Notes</strong></p><p>This is the in-place version of <code>scale</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/337c0558eaef739dd15e78b47f3aecd65c1c69a1/src/operations/arithmetic.jl#L130-L148">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntervalMatrices.set_multiplication_mode" href="#IntervalMatrices.set_multiplication_mode"><code>IntervalMatrices.set_multiplication_mode</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">set_multiplication_mode(multype)</code></pre><p>Sets the algorithm used to perform matrix multiplication with interval matrices.</p><p><strong>Input</strong></p><ul><li><code>multype</code> – symbol describing the algorithm used<ul><li><code>:slow</code> – uses traditional matrix multiplication algorithm.</li><li><code>:fast</code> – computes an enclosure of the matrix product using the midpoint-radius            notation of the matrix [<a href="../../bibliography/#Rump10">Rum10</a>].</li></ul></li></ul><div class="admonition is-info" id=":fast-option-no-longer-supported-730b8f3193072a17"><header class="admonition-header">:fast option no longer supported<a class="admonition-anchor" href="#:fast-option-no-longer-supported-730b8f3193072a17" title="Permalink"></a></header><div class="admonition-body"><p><code>:fast</code> support was removed in <code>IntervalArithmetic</code> v0.22.</p></div></div><p><strong>Notes</strong></p><ul><li>By default, <code>:slow</code> is used.</li><li>Using <code>fast</code> is generally significantly faster, but it may return larger intervals, especially if midpoint and radius have the same order of magnitude   (50% overestimate at most) [<a href="../../bibliography/#Rump99">Rum99</a>].</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/337c0558eaef739dd15e78b47f3aecd65c1c69a1/src/operations/mult.jl#L7-L28">source</a></section></article><h2 id="Matrix-power"><a class="docs-heading-anchor" href="#Matrix-power">Matrix power</a><a id="Matrix-power-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-power" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntervalMatrices.increment!" href="#IntervalMatrices.increment!"><code>IntervalMatrices.increment!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">increment!(pow::IntervalMatrixPower; [algorithm=default_algorithm])</code></pre><p>Increment a matrix power in-place (i.e., storing the result in <code>pow</code>).</p><p><strong>Input</strong></p><ul><li><code>pow</code>       – wrapper of a matrix power (modified in this function)</li><li><code>algorithm</code> – (optional; default: <code>default_algorithm</code>) algorithm to compute                the matrix power; available options:<ul><li><code>&quot;multiply&quot;</code> – fast computation using <code>*</code> from the previous result</li><li><code>&quot;power&quot;</code> – recomputation using <code>^</code></li><li><code>&quot;decompose_binary&quot;</code> – decompose <code>k = 2a + b</code></li><li><code>&quot;intersect&quot;</code> – combination of <code>&quot;multiply&quot;</code>/<code>&quot;power&quot;</code>/<code>&quot;decompose_binary&quot;</code></li></ul></li></ul><p><strong>Output</strong></p><p>The next matrix power, reflected in the modified wrapper.</p><p><strong>Notes</strong></p><p>Independent of <code>&quot;algorithm&quot;</code>, if the index is a power of two, we compute the exact result using squaring.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/337c0558eaef739dd15e78b47f3aecd65c1c69a1/src/operations/power.jl#L84-L107">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntervalMatrices.increment" href="#IntervalMatrices.increment"><code>IntervalMatrices.increment</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">increment(pow::IntervalMatrixPower; [algorithm=default_algorithm])</code></pre><p>Increment a matrix power without modifying <code>pow</code>.</p><p><strong>Input</strong></p><ul><li><code>pow</code> – wrapper of a matrix power</li><li><code>algorithm</code> – (optional; default: <code>default_algorithm</code>) algorithm to compute                the matrix power; see <a href="#IntervalMatrices.increment!"><code>increment!</code></a> for available options</li></ul><p><strong>Output</strong></p><p>The next matrix power.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/337c0558eaef739dd15e78b47f3aecd65c1c69a1/src/operations/power.jl#L129-L143">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntervalMatrices.matrix" href="#IntervalMatrices.matrix"><code>IntervalMatrices.matrix</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">matrix(pow::IntervalMatrixPower)</code></pre><p>Return the matrix represented by a wrapper of a matrix power.</p><p><strong>Input</strong></p><ul><li><code>pow</code> – wrapper of a matrix power</li></ul><p><strong>Output</strong></p><p>The matrix power represented by the wrapper.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/337c0558eaef739dd15e78b47f3aecd65c1c69a1/src/operations/power.jl#L212-L224">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntervalMatrices.base" href="#IntervalMatrices.base"><code>IntervalMatrices.base</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">base(pow::IntervalMatrixPower)</code></pre><p>Return the original matrix represented by a wrapper of a matrix power.</p><p><strong>Input</strong></p><ul><li><code>pow</code> – wrapper of a matrix power</li></ul><p><strong>Output</strong></p><p>The matrix <span>$M$</span> being the basis of the matrix power <span>$M^k$</span> represented by the wrapper.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/337c0558eaef739dd15e78b47f3aecd65c1c69a1/src/operations/power.jl#L194-L207">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntervalMatrices.index" href="#IntervalMatrices.index"><code>IntervalMatrices.index</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">index(pow::IntervalMatrixPower)</code></pre><p>Return the current index of the wrapper of a matrix power.</p><p><strong>Input</strong></p><ul><li><code>pow</code> – wrapper of a matrix power</li></ul><p><strong>Output</strong></p><p>The index <code>k</code> of the wrapper representing <span>$M^k$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/337c0558eaef739dd15e78b47f3aecd65c1c69a1/src/operations/power.jl#L229-L241">source</a></section></article><h2 id="Matrix-exponential"><a class="docs-heading-anchor" href="#Matrix-exponential">Matrix exponential</a><a id="Matrix-exponential-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-exponential" title="Permalink"></a></h2><h3 id="Algorithms"><a class="docs-heading-anchor" href="#Algorithms">Algorithms</a><a id="Algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Algorithms" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntervalMatrices.Horner" href="#IntervalMatrices.Horner"><code>IntervalMatrices.Horner</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Horner &lt;: AbstractExponentiationMethod</code></pre><p>Matrix exponential using Horner&#39;s method.</p><p><strong>Fields</strong></p><ul><li><code>K</code> – number of expansions in the Horner scheme</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/337c0558eaef739dd15e78b47f3aecd65c1c69a1/src/exponential.jl#L349-L357">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntervalMatrices.ScaleAndSquare" href="#IntervalMatrices.ScaleAndSquare"><code>IntervalMatrices.ScaleAndSquare</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ScaleAndSquare &lt;: AbstractExponentiationMethod</code></pre><p><strong>Fields</strong></p><ul><li><code>l</code> – scaling-and-squaring order</li><li><code>p</code> – order of the approximation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/337c0558eaef739dd15e78b47f3aecd65c1c69a1/src/exponential.jl#L283-L290">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntervalMatrices.TaylorOverapproximation" href="#IntervalMatrices.TaylorOverapproximation"><code>IntervalMatrices.TaylorOverapproximation</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TaylorOverapproximation &lt;: AbstractExponentiationMethod</code></pre><p>Matrix exponential overapproximation using a truncated Taylor series.</p><p><strong>Fields</strong></p><ul><li><code>p</code> – order of the approximation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/337c0558eaef739dd15e78b47f3aecd65c1c69a1/src/exponential.jl#L17-L25">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntervalMatrices.TaylorUnderapproximation" href="#IntervalMatrices.TaylorUnderapproximation"><code>IntervalMatrices.TaylorUnderapproximation</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TaylorUnderapproximation &lt;: AbstractExponentiationMethod</code></pre><p>Matrix exponential underapproximation using a truncated Taylor series.</p><p><strong>Fields</strong></p><ul><li><code>p</code> – order of the approximation</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/337c0558eaef739dd15e78b47f3aecd65c1c69a1/src/exponential.jl#L34-L42">source</a></section></article><h3 id="Implementations"><a class="docs-heading-anchor" href="#Implementations">Implementations</a><a id="Implementations-1"></a><a class="docs-heading-anchor-permalink" href="#Implementations" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntervalMatrices.exp_overapproximation" href="#IntervalMatrices.exp_overapproximation"><code>IntervalMatrices.exp_overapproximation</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">exp_overapproximation(A::IntervalMatrix{T}, t, p)</code></pre><p>Overapproximation of the exponential of an interval matrix, <code>exp(A*t)</code>, using a truncated Taylor series.</p><p><strong>Input</strong></p><ul><li><code>A</code> – interval matrix</li><li><code>t</code> – exponentiation factor</li><li><code>p</code> – order of the approximation</li></ul><p><strong>Output</strong></p><p>A matrix enclosure of <code>exp(A*t)</code>, i.e. an interval matrix <code>M = (m_{ij})</code> such that <code>[exp(A*t)]_{ij} ⊆ m_{ij}</code>.</p><p><strong>Algorithm</strong></p><p>See <a href="../../bibliography/#AlthoffSB07">Althoff <em>et al.</em> [ASB07]</a>, Theorem 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/337c0558eaef739dd15e78b47f3aecd65c1c69a1/src/exponential.jl#L51-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntervalMatrices.horner" href="#IntervalMatrices.horner"><code>IntervalMatrices.horner</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">horner(A::IntervalMatrix{T}, K::Integer; [validate]::Bool=true)</code></pre><p>Compute the matrix exponential using the Horner scheme.</p><p><strong>Input</strong></p><ul><li><code>A</code> – interval matrix</li><li><code>K</code> – number of expansions in the Horner scheme</li><li><code>validate</code> – (optional; default: <code>true</code>) option to validate the precondition               of the algorithm</li></ul><p><strong>Algorithm</strong></p><p>We use the algorithm in <a href="../../bibliography/#GoldsztejnN14">Goldsztejn and Neumaier [GN14]</a>, Section 4.2.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/337c0558eaef739dd15e78b47f3aecd65c1c69a1/src/exponential.jl#L367-L382">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntervalMatrices.scale_and_square" href="#IntervalMatrices.scale_and_square"><code>IntervalMatrices.scale_and_square</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">scale_and_square(A::IntervalMatrix{T}, l::Integer, t, p;
                 [validate]::Bool=true)</code></pre><p>Compute the matrix exponential using scaling and squaring.</p><p><strong>Input</strong></p><ul><li><code>A</code> – interval matrix</li><li><code>l</code> – scaling-and-squaring order</li><li><code>t</code> – non-negative time value</li><li><code>p</code> – order of the approximation</li><li><code>validate</code> – (optional; default: <code>true</code>) option to validate the precondition               of the algorithm</li></ul><p><strong>Algorithm</strong></p><p>We use the algorithm in <a href="../../bibliography/#GoldsztejnN14">Goldsztejn and Neumaier [GN14]</a>, Section 4.3, which first scales <code>A</code> by factor <span>$2^{-l}$</span>, computes the matrix exponential for the scaled matrix, and then squares the result <span>$l$</span> times.</p><p class="math-container">\[    \exp(A * 2^{-l})^{2^l}\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/337c0558eaef739dd15e78b47f3aecd65c1c69a1/src/exponential.jl#L300-L324">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntervalMatrices.exp_underapproximation" href="#IntervalMatrices.exp_underapproximation"><code>IntervalMatrices.exp_underapproximation</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">exp_underapproximation(A::IntervalMatrix{T}, t, p) where {T}</code></pre><p>Underapproximation of the exponential of an interval matrix, <code>exp(A*t)</code>, using a truncated Taylor series expansion.</p><p><strong>Input</strong></p><ul><li><code>A</code> – interval matrix</li><li><code>t</code> – exponentiation factor</li><li><code>p</code> – order of the approximation</li></ul><p><strong>Output</strong></p><p>An underapproximation of <code>exp(A*t)</code>, i.e. an interval matrix <code>M = (m_{ij})</code> such that <code>m_{ij} ⊆ [exp(A*t)]_{ij}</code>.</p><p><strong>Algorithm</strong></p><p>See <a href="../../bibliography/#AlthoffSB07">Althoff <em>et al.</em> [ASB07]</a>, Theorem 2.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/337c0558eaef739dd15e78b47f3aecd65c1c69a1/src/exponential.jl#L113-L133">source</a></section></article><h2 id="Finite-expansions"><a class="docs-heading-anchor" href="#Finite-expansions">Finite expansions</a><a id="Finite-expansions-1"></a><a class="docs-heading-anchor-permalink" href="#Finite-expansions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntervalMatrices.quadratic_expansion" href="#IntervalMatrices.quadratic_expansion"><code>IntervalMatrices.quadratic_expansion</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">quadratic_expansion(A::IntervalMatrix, α::Real, β::Real)</code></pre><p>Compute the quadratic expansion of an interval matrix, <span>$αA + βA^2$</span>, using interval arithmetic.</p><p><strong>Input</strong></p><ul><li><code>A</code> – interval matrix</li><li><code>α</code> – linear coefficient</li><li><code>β</code> – quadratic coefficient</li></ul><p><strong>Output</strong></p><p>An interval matrix that encloses <span>$B := αA + βA^2$</span>.</p><p><strong>Algorithm</strong></p><p>This a variation of the algorithm in <a href="../../bibliography/#KoshelevaKMN05">Kosheleva <em>et al.</em> [KKMN05]</a>, Section 6. If <span>$A = (aᵢⱼ)$</span> and <span>$B := αA + βA^2 = (bᵢⱼ)$</span>, the idea is to compute each <span>$bᵢⱼ$</span> by factoring out repeated expressions (thus the term <em>single-use expressions</em>).</p><p>First, let <span>$i = j$</span>. In this case,</p><p class="math-container">\[bⱼⱼ = β\sum_\{k, k ≠ j} a_{jk} a_{kj} + (α + βa_{jj}) a_{jj}.\]</p><p>Now consider <span>$i ≠ j$</span>. Then,</p><p class="math-container">\[bᵢⱼ = β\sum_\{k, k ≠ i, k ≠ j} a_{ik} a_{kj} + (α + βa_{ii} + βa_{jj}) a_{ij}.\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/337c0558eaef739dd15e78b47f3aecd65c1c69a1/src/exponential.jl#L175-L208">source</a></section></article><h2 id="Correction-terms"><a class="docs-heading-anchor" href="#Correction-terms">Correction terms</a><a id="Correction-terms-1"></a><a class="docs-heading-anchor-permalink" href="#Correction-terms" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntervalMatrices.correction_hull" href="#IntervalMatrices.correction_hull"><code>IntervalMatrices.correction_hull</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">correction_hull(A::IntervalMatrix{T}, t, p) where {T}</code></pre><p>Compute the correction term for the convex hull of a point and its linear map with an interval matrix in order to contain all trajectories of a linear system.</p><p><strong>Input</strong></p><ul><li><code>A</code> – interval matrix</li><li><code>t</code> – non-negative time value</li><li><code>p</code> – order of the approximation</li></ul><p><strong>Output</strong></p><p>An interval matrix representing the correction term.</p><p><strong>Algorithm</strong></p><p>See <a href="../../bibliography/#AlthoffSB07">Althoff <em>et al.</em> [ASB07]</a>, Theorem 3.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/337c0558eaef739dd15e78b47f3aecd65c1c69a1/src/correction_matrices.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntervalMatrices.input_correction" href="#IntervalMatrices.input_correction"><code>IntervalMatrices.input_correction</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">input_correction(A::IntervalMatrix{T}, t, p) where {T}</code></pre><p>Compute the <em>input correction matrix</em> for discretizing an inhomogeneous affine dynamical system with an interval matrix and an input domain not containing the origin.</p><p><strong>Input</strong></p><ul><li><code>A</code> – interval matrix</li><li><code>t</code> – non-negative time value</li><li><code>p</code> – order of the Taylor approximation</li></ul><p><strong>Output</strong></p><p>An interval matrix representing the correction matrix.</p><p><strong>Algorithm</strong></p><p>See <a href="../../bibliography/#Althoff10">Althoff [Alt10]</a>, Proposition 3.4.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/337c0558eaef739dd15e78b47f3aecd65c1c69a1/src/correction_matrices.jl#L32-L52">source</a></section></article><h2 id="Norms"><a class="docs-heading-anchor" href="#Norms">Norms</a><a id="Norms-1"></a><a class="docs-heading-anchor-permalink" href="#Norms" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.opnorm" href="#LinearAlgebra.opnorm"><code>LinearAlgebra.opnorm</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">opnorm(A::IntervalMatrix, p::Real=Inf)</code></pre><p>The matrix norm of an interval matrix.</p><p><strong>Input</strong></p><ul><li><code>A</code> – interval matrix</li><li><code>p</code> – (optional, default: <code>Inf</code>) the class of <code>p</code>-norm</li></ul><p><strong>Notes</strong></p><p>The matrix <span>$p$</span>-norm of an interval matrix <span>$A$</span> is defined as</p><p class="math-container">\[    ‖A‖_p := ‖\max(|\text{inf}(A)|, |\text{sup}(A)|)‖_p\]</p><p>where <span>$\max$</span> and <span>$|·|$</span> are taken elementwise.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/337c0558eaef739dd15e78b47f3aecd65c1c69a1/src/operations/norm.jl#L1-L20">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IntervalMatrices.diam_norm" href="#IntervalMatrices.diam_norm"><code>IntervalMatrices.diam_norm</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">diam_norm(A::IntervalMatrix, p=Inf)</code></pre><p>Return the diameter norm of the interval matrix.</p><p><strong>Input</strong></p><ul><li><code>A</code> – interval matrix</li><li><code>p</code> – (optional, default: <code>Inf</code>) the <code>p</code>-norm used; valid options are:        <code>1</code>, <code>2</code>, <code>Inf</code></li></ul><p><strong>Output</strong></p><p>The operator norm, in the <code>p</code>-norm, of the scalar matrix obtained by taking the element-wise <code>diam</code> function, where <code>diam(x) := sup(x) - inf(x)</code> for an interval <code>x</code>.</p><p><strong>Notes</strong></p><p>This function gives a measure of the <em>width</em> of the interval matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/337c0558eaef739dd15e78b47f3aecd65c1c69a1/src/operations/norm.jl#L67-L87">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../types/">« Types</a><a class="docs-footer-nextpage" href="../../about/">About »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Sunday 24 August 2025 15:52">Sunday 24 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
