<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Methods · IntervalMatrices.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/juliareach.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>IntervalMatrices.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="../types/">Types</a></li><li class="current"><a class="toctext" href>Methods</a><ul class="internal"><li><a class="toctext" href="#Common-functions-1">Common functions</a></li><li><a class="toctext" href="#Matrix-power-1">Matrix power</a></li><li><a class="toctext" href="#Exponentiation-1">Exponentiation</a></li><li><a class="toctext" href="#Finite-expansions-1">Finite expansions</a></li><li><a class="toctext" href="#Correction-terms-1">Correction terms</a></li><li><a class="toctext" href="#Norms-1">Norms</a></li></ul></li></ul></li><li><a class="toctext" href="../../about/">About</a></li></ul></nav><article id="docs"><header><nav><ul><li>Library</li><li><a href>Methods</a></li></ul><a class="edit-page" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/master/docs/src/lib/methods.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Methods</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Methods-1" href="#Methods-1">Methods</a></h1><p>This section describes systems methods implemented in <code>IntervalMatrices.jl</code>.</p><ul><li><a href="#Methods-1">Methods</a></li><ul><li><a href="#Common-functions-1">Common functions</a></li><li><a href="#Matrix-power-1">Matrix power</a></li><li><a href="#Exponentiation-1">Exponentiation</a></li><li><a href="#Finite-expansions-1">Finite expansions</a></li><li><a href="#Correction-terms-1">Correction terms</a></li><li><a href="#Norms-1">Norms</a></li></ul></ul><h2><a class="nav-anchor" id="Common-functions-1" href="#Common-functions-1">Common functions</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalArithmetic.inf" href="#IntervalArithmetic.inf"><code>IntervalArithmetic.inf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">inf(A::IntervalMatrix{T}) where {T}</code></pre><p>Return the infimum of an interval matrix <code>A</code>, which corresponds to taking the element-wise infimum of <code>A</code>.</p><p><strong>Input</strong></p><ul><li><code>A</code> – interval matrix</li></ul><p><strong>Output</strong></p><p>A scalar matrix whose coefficients are the infima of each element in <code>A</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/306b3527c8781ef534428eb53121cff47242a0df/src/matrix.jl#L215-L228">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalArithmetic.sup" href="#IntervalArithmetic.sup"><code>IntervalArithmetic.sup</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">sup(A::IntervalMatrix{T}) where {T}</code></pre><p>Return the supremum of an interval matrix <code>A</code>, which corresponds to taking the element-wise supremum of <code>A</code>.</p><p><strong>Input</strong></p><ul><li><code>A</code> – interval matrix</li></ul><p><strong>Output</strong></p><p>A scalar matrix whose coefficients are the suprema of each element in <code>A</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/306b3527c8781ef534428eb53121cff47242a0df/src/matrix.jl#L233-L246">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalArithmetic.mid" href="#IntervalArithmetic.mid"><code>IntervalArithmetic.mid</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">mid(A::IntervalMatrix{T}) where {T}</code></pre><p>Return the midpoint of an interval matrix <code>A</code>, which corresponds to taking the element-wise midpoint of <code>A</code>.</p><p><strong>Input</strong></p><ul><li><code>A</code> – interval matrix</li></ul><p><strong>Output</strong></p><p>A scalar matrix whose coefficients are the midpoints of each element in <code>A</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/306b3527c8781ef534428eb53121cff47242a0df/src/matrix.jl#L251-L264">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalArithmetic.diam" href="#IntervalArithmetic.diam"><code>IntervalArithmetic.diam</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">diam(A::IntervalMatrix{T}) where {T}</code></pre><p>Return a matrix whose entries describe the diameters of the intervals.</p><p><strong>Input</strong></p><ul><li><code>A</code> – interval matrix</li></ul><p><strong>Output</strong></p><p>A matrix <code>B</code> of the same shape as <code>A</code> such that <code>B[i, j] == diam(A[i, j])</code> for each <code>i</code> and <code>j</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/306b3527c8781ef534428eb53121cff47242a0df/src/matrix.jl#L438-L451">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.rand" href="#Base.rand"><code>Base.rand</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">rand(::Type{IntervalMatrix}, m::Int=2, [n]::Int=m;
     N=Float64, rng::AbstractRNG=GLOBAL_RNG)</code></pre><p>Return a random interval matrix of the given size and numeric type.</p><p><strong>Input</strong></p><ul><li><code>IntervalMatrix</code> – type, used for dispatch</li><li><code>m</code>              – (optional, default: <code>2</code>) number of rows</li><li><code>n</code>              – (optional, default: <code>m</code>) number of columns</li><li><code>rng</code>            – (optional, default: <code>GLOBAL_RNG</code>) random-number generator</li></ul><p><strong>Output</strong></p><p>An interval matrix of size <span>$m × n$</span> whose coefficients are normally-distributed intervals of type <code>N</code> with mean <code>0</code> and standard deviation <code>1</code>.</p><p><strong>Notes</strong></p><p>If this function is called with only one argument, it creates a square matrix, because the number of columns defaults to the number of rows.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/306b3527c8781ef534428eb53121cff47242a0df/src/matrix.jl#L375-L397">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalMatrices.sample" href="#IntervalMatrices.sample"><code>IntervalMatrices.sample</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">sample(A::IntervalMatrix{T}; rng::AbstractRNG=GLOBAL_RNG) where {T}</code></pre><p>Return a sample of the given random interval matrix.</p><p><strong>Input</strong></p><ul><li><code>A</code>   – interval matrix</li><li><code>m</code>   – (optional, default: <code>2</code>) number of rows</li><li><code>n</code>   – (optional, default: <code>2</code>) number of columns</li><li><code>rng</code> – (optional, default: <code>GLOBAL_RNG</code>) random-number generator</li></ul><p><strong>Output</strong></p><p>An interval matrix of size <span>$m × n$</span> whose coefficients are normally-distributed intervals of type <code>N</code> with mean <code>0</code> and standard deviation <code>1</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/306b3527c8781ef534428eb53121cff47242a0df/src/matrix.jl#L409-L425">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.split" href="#Base.split"><code>Base.split</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">split(A::IntervalMatrix{T}) where {T}</code></pre><p>Split an interval matrix <span>$A$</span> into two scalar matrices <span>$C$</span> and <span>$S$</span> such that <span>$A = C + [-S, S]$</span>.</p><p><strong>Input</strong></p><ul><li><code>A</code> – interval matrix</li></ul><p><strong>Output</strong></p><p>A pair <code>(C, S)</code> such that the entries of <code>C</code> are the central points and the entries of <code>S</code> are the (nonnegative) radii of the intervals in <code>A</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/306b3527c8781ef534428eb53121cff47242a0df/src/matrix.jl#L269-L283">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈" href="#Base.:∈"><code>Base.:∈</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">∈(M::AbstractMatrix, A::AbstractIntervalMatrix)</code></pre><p>Check whether a concrete matrix is an instance of an interval matrix.</p><p><strong>Input</strong></p><ul><li><code>M</code> – concrete matrix</li><li><code>A</code> – interval matrix</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <code>M</code> is an instance of <code>A</code></p><p><strong>Algorithm</strong></p><p>We check for each entry in <code>M</code> whether it belongs to the corresponding interval in <code>A</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/306b3527c8781ef534428eb53121cff47242a0df/src/matrix.jl#L301-L319">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalMatrices.square" href="#IntervalMatrices.square"><code>IntervalMatrices.square</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">square(A::IntervalMatrix)</code></pre><p>Compute the square of an interval matrix.</p><p><strong>Input</strong></p><ul><li><code>A</code> – interval matrix</li></ul><p><strong>Output</strong></p><p>An interval matrix equivalent to <code>A * A</code>.</p><p><strong>Algorithm</strong></p><p>We follow [1, Section 6].</p><p>[1] Kosheleva, Kreinovich, Mayer, Nguyen. Computing the cube of an interval matrix is NP-hard. SAC 2005.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/306b3527c8781ef534428eb53121cff47242a0df/src/arithmetic.jl#L42-L61">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalMatrices.scale" href="#IntervalMatrices.scale"><code>IntervalMatrices.scale</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">scale(A::IntervalMatrix{T}, α::T) where {T}</code></pre><p>Return a new interval matrix whose entries are scaled by the given factor.</p><p><strong>Input</strong></p><ul><li><code>A</code> – interval matrix</li><li><code>α</code> – scaling factor</li></ul><p><strong>Output</strong></p><p>A new matrix <code>B</code> of the same shape as <code>A</code> such that <code>B[i, j] = α*A[i, j]</code> for each <code>i</code> and <code>j</code>.</p><p><strong>Notes</strong></p><p>See <code>scale!</code> for the in-place version of this function.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/306b3527c8781ef534428eb53121cff47242a0df/src/matrix.jl#L456-L474">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalMatrices.scale!" href="#IntervalMatrices.scale!"><code>IntervalMatrices.scale!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">scale(A::IntervalMatrix{T}, α::T) where {T}</code></pre><p>Modifies the given interval matrix, scaling its entries by the given factor.</p><p><strong>Input</strong></p><ul><li><code>A</code> – interval matrix</li><li><code>α</code> – scaling factor</li></ul><p><strong>Output</strong></p><p>The matrix <code>A</code> such that for each <code>i</code> and <code>j</code>, the new value of <code>A[i, j]</code> is <code>α*A[i, j]</code>.</p><p><strong>Notes</strong></p><p>This is the in-place version of <code>scale</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/306b3527c8781ef534428eb53121cff47242a0df/src/matrix.jl#L479-L497">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:⊆" href="#Base.:⊆"><code>Base.:⊆</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">⊆(A::AbstractIntervalMatrix, B::AbstractIntervalMatrix)</code></pre><p>Check whether an interval matrix is contained in another interval matrix.</p><p><strong>Input</strong></p><ul><li><code>A</code> – interval matrix</li><li><code>B</code> – interval matrix</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <code>A[i, j] ⊆ B[i, j]</code> for all <code>i, j</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/306b3527c8781ef534428eb53121cff47242a0df/src/matrix.jl#L335-L348">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∩" href="#Base.:∩"><code>Base.:∩</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">∩(A::IntervalMatrix, B::IntervalMatrix)</code></pre><p>Intersect two interval matrices.</p><p><strong>Input</strong></p><ul><li><code>A</code> – interval matrix</li><li><code>B</code> – interval matrix (of the same shape as <code>A</code>)</li></ul><p><strong>Output</strong></p><p>A new matrix <code>C</code> of the same shape as <code>A</code> such that <code>C[i, j] = A[i, j] ∩ B[i, j]</code> for each <code>i</code> and <code>j</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/306b3527c8781ef534428eb53121cff47242a0df/src/matrix.jl#L502-L516">source</a></section><h2><a class="nav-anchor" id="Matrix-power-1" href="#Matrix-power-1">Matrix power</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalMatrices.increment!" href="#IntervalMatrices.increment!"><code>IntervalMatrices.increment!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">increment!(pow::IntervalMatrixPower; [algorithm=default_algorithm])</code></pre><p>Increment a matrix power in-place (i.e., storing the result in <code>pow</code>).</p><p><strong>Input</strong></p><ul><li><code>pow</code>       – wrapper of a matrix power (modified in this function)</li><li><code>algorithm</code> – (optional; default: <code>default_algorithm</code>) algorithm to compute                the matrix power; available options:<ul><li><code>&quot;multiply&quot;</code> – fast computation using <code>*</code> from the previous result</li><li><code>&quot;power&quot;</code> – recomputation using <code>^</code></li><li><code>&quot;decompose_binary&quot;</code> – decompose <code>k = 2a + b</code></li><li><code>&quot;intersect&quot;</code> – combination of <code>&quot;multiply&quot;</code>/<code>&quot;power&quot;</code>/<code>&quot;decompose_binary&quot;</code></li></ul></li></ul><p><strong>Output</strong></p><p>The next matrix power, reflected in the modified wrapper.</p><p><strong>Notes</strong></p><p>Independent of <code>&quot;algorithm&quot;</code>, if the index is a power of two, we compute the exact result using squaring.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/306b3527c8781ef534428eb53121cff47242a0df/src/power.jl#L86-L109">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalMatrices.increment" href="#IntervalMatrices.increment"><code>IntervalMatrices.increment</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">increment(pow::IntervalMatrixPower; [algorithm=default_algorithm])</code></pre><p>Increment a matrix power without modifying <code>pow</code>.</p><p><strong>Input</strong></p><ul><li><code>pow</code> – wrapper of a matrix power</li><li><code>algorithm</code> – (optional; default: <code>default_algorithm</code>) algorithm to compute                the matrix power; see <a href="#IntervalMatrices.increment!"><code>increment!</code></a> for available options</li></ul><p><strong>Output</strong></p><p>The next matrix power.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/306b3527c8781ef534428eb53121cff47242a0df/src/power.jl#L130-L144">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.get" href="#Base.get"><code>Base.get</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">get(pow::IntervalMatrixPower)</code></pre><p>Return the matrix represented by a wrapper of a matrix power.</p><p><strong>Input</strong></p><ul><li><code>pow</code> – wrapper of a matrix power</li></ul><p><strong>Output</strong></p><p>The matrix power represented by the wrapper.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/306b3527c8781ef534428eb53121cff47242a0df/src/power.jl#L213-L225">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalMatrices.base" href="#IntervalMatrices.base"><code>IntervalMatrices.base</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">base(pow::IntervalMatrixPower)</code></pre><p>Return the original matrix represented by a wrapper of a matrix power.</p><p><strong>Input</strong></p><ul><li><code>pow</code> – wrapper of a matrix power</li></ul><p><strong>Output</strong></p><p>The matrix <span>$M$</span> being the basis of the matrix power <span>$M^k$</span> represented by the wrapper.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/306b3527c8781ef534428eb53121cff47242a0df/src/power.jl#L195-L208">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalMatrices.index" href="#IntervalMatrices.index"><code>IntervalMatrices.index</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">index(pow::IntervalMatrixPower)</code></pre><p>Return the current index of the wrapper of a matrix power.</p><p><strong>Input</strong></p><ul><li><code>pow</code> – wrapper of a matrix power</li></ul><p><strong>Output</strong></p><p>The index <code>k</code> of the wrapper representing <span>$M^k$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/306b3527c8781ef534428eb53121cff47242a0df/src/power.jl#L230-L242">source</a></section><h2><a class="nav-anchor" id="Exponentiation-1" href="#Exponentiation-1">Exponentiation</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalMatrices.exp_overapproximation" href="#IntervalMatrices.exp_overapproximation"><code>IntervalMatrices.exp_overapproximation</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">exp_overapproximation(A::IntervalMatrix{T, Interval{T}}, t, p) where {T}</code></pre><p>Overapproximation of the exponential of an interval matrix.</p><p><strong>Input</strong></p><ul><li><code>A</code> – interval matrix</li><li><code>t</code> – non-negative time value</li><li><code>p</code> – order of the approximation</li></ul><p><strong>Algorithm</strong></p><p>See Theorem 1 in <em>Reachability Analysis of Linear Systems with Uncertain Parameters and Inputs</em> by M. Althoff, O. Stursberg, M. Buss.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/306b3527c8781ef534428eb53121cff47242a0df/src/exponential.jl#L161-L176">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalMatrices.horner" href="#IntervalMatrices.horner"><code>IntervalMatrices.horner</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">horner(A::IntervalMatrix{T}, K::Integer; [validate]::Bool=true)</code></pre><p>Compute the matrix exponential using the Horner scheme.</p><p><strong>Input</strong></p><ul><li><code>A</code> – interval matrix</li><li><code>K</code> – number of expansions in the Horner scheme</li><li><code>validate</code> – (optional; default: <code>true</code>) option to validate the precondition               of the algorithm</li></ul><p><strong>Algorithm</strong></p><p>We use the algorithm in [1, Section 4.2].</p><p>[1] Goldsztejn, Alexandre, Arnold Neumaier. &quot;On the exponentiation of interval matrices&quot;. Reliable Computing. 2014.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/306b3527c8781ef534428eb53121cff47242a0df/src/exponential.jl#L222-L240">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalMatrices.scale_and_square" href="#IntervalMatrices.scale_and_square"><code>IntervalMatrices.scale_and_square</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">scale_and_square(A::IntervalMatrix{T}, l::Integer, t, p;
                 [validate]::Bool=true)</code></pre><p>Compute the matrix exponential using scaling and squaring.</p><p><strong>Input</strong></p><ul><li><code>A</code> – interval matrix</li><li><code>l</code> – scaling-and-squaring order</li><li><code>t</code> – non-negative time value</li><li><code>p</code> – order of the approximation</li><li><code>validate</code> – (optional; default: <code>true</code>) option to validate the precondition               of the algorithm</li></ul><p><strong>Algorithm</strong></p><p>We use the algorithm in [1, Section 4.3], which first scales <code>A</code> by factor <span>$2^{-l}$</span>, computes the matrix exponential for the scaled matrix, and then squares the result <span>$l$</span> times.</p><div>\[    \exp(A * 2^{-l})^{2^l}\]</div><p>[1] Goldsztejn, Alexandre, Arnold Neumaier. &quot;On the exponentiation of interval matrices&quot;. Reliable Computing. 2014.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/306b3527c8781ef534428eb53121cff47242a0df/src/exponential.jl#L270-L297">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalMatrices.exp_underapproximation" href="#IntervalMatrices.exp_underapproximation"><code>IntervalMatrices.exp_underapproximation</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">exp_underapproximation(M::IntervalMatrix{T, Interval{T}}, t, p) where {T}</code></pre><p>Overapproximation of the exponential of an interval matrix.</p><p><strong>Input</strong></p><ul><li><code>A</code> – interval matrix</li><li><code>t</code> – non-negative time value</li><li><code>p</code> – order of the approximation</li></ul><p><strong>Algorithm</strong></p><p>See Theorem 2 in <em>Reachability Analysis of Linear Systems with Uncertain Parameters and Inputs</em> by M. Althoff, O. Stursberg, M. Buss.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/306b3527c8781ef534428eb53121cff47242a0df/src/exponential.jl#L318-L333">source</a></section><h2><a class="nav-anchor" id="Finite-expansions-1" href="#Finite-expansions-1">Finite expansions</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalMatrices.quadratic_expansion" href="#IntervalMatrices.quadratic_expansion"><code>IntervalMatrices.quadratic_expansion</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">quadratic_expansion(A::IntervalMatrix, t)</code></pre><p>Exactly compute the quadratic formula <span>$At + \frac{1}{2}A^2t^2$</span> using interval arithmetics.</p><p><strong>Input</strong></p><ul><li><code>A</code> – interval matrix</li><li><code>t</code> – non-negative time value</li></ul><p><strong>Algorithm</strong></p><p>See Lemma 1 in <em>Reachability Analysis of Linear Systems with Uncertain Parameters and Inputs</em> by M. Althoff, O. Stursberg, M. Buss.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/306b3527c8781ef534428eb53121cff47242a0df/src/exponential.jl#L3-L18">source</a><div><div><pre><code class="language-none">quadratic_expansion(A::IntervalMatrix, α::Real, β::Real)</code></pre><p>Compute the quadratic expansion of an interval matrix, <span>$αA + βA^2$</span>, using interval arithmetics.</p><p><strong>Input</strong></p><ul><li><code>A</code> – interval matrix</li><li><code>α</code> – linear coefficient</li><li><code>β</code> – quadratic coefficient</li></ul><p><strong>Output</strong></p><p>An interval matrix that encloses <span>$B := αA + βA^2$</span>.</p><p><strong>Algorithm</strong></p><p>This a variation of the algorithm in [1, Section 6]. If <span>$A = (aᵢⱼ)$</span> and <span>$B := αA + βA^2 = (bᵢⱼ)$</span>, the idea is to compute each <span>$bᵢⱼ$</span> by factoring out repeated expressions (thus the term <em>single-use expressions</em>).</p><p>First, let <span>$i = j$</span>. In this case,</p><div>\[bⱼⱼ = β\sum_\{k, k ≠ j} a_{jk} a_{kj} + (α + βa_{jj}) a_{jj}.\]</div><p>Now consider <span>$i ≠ j$</span>. Then,</p><div>\[bᵢⱼ = β\sum_\{k, k ≠ i, k ≠ j} a_{ik} a_{kj} + (α + βa_{ii} + βa_{jj}) a_{ij}.\]</div><p>[1] Kosheleva, Kreinovich, Mayer, Nguyen. Computing the cube of an interval matrix is NP-hard. SAC 2005.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/306b3527c8781ef534428eb53121cff47242a0df/src/exponential.jl#L60-L96">source</a></section><h2><a class="nav-anchor" id="Correction-terms-1" href="#Correction-terms-1">Correction terms</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalMatrices.correction_hull" href="#IntervalMatrices.correction_hull"><code>IntervalMatrices.correction_hull</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">correction_hull(A::IntervalMatrix{T}, t, p) where {T}</code></pre><p>Compute the correction term for the convex hull of a point and its linear map with an interval matrix in order to contain all trajectories of a linear system.</p><p><strong>Input</strong></p><ul><li><code>A</code> – interval matrix</li><li><code>t</code> – non-negative time value</li><li><code>p</code> – order of the approximation</li></ul><p><strong>Output</strong></p><p>An interval matrix representing the correction term.</p><p><strong>Algorithm</strong></p><p>See Theorem 3 in [1].</p><p>[1] M. Althoff, O. Stursberg, M. Buss. Reachability Analysis of Linear Systems with Uncertain Parameters and Inputs. CDC 2007.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/306b3527c8781ef534428eb53121cff47242a0df/src/correction_matrices.jl#L1-L23">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalMatrices.input_correction" href="#IntervalMatrices.input_correction"><code>IntervalMatrices.input_correction</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">input_correction(A::IntervalMatrix{T}, t, p) where {T}</code></pre><p>Compute the <em>input correction matrix</em> for discretizing an inhomogeneous affine dynamical system with an interval matrix and an input domain not containing the origin.</p><p><strong>Input</strong></p><ul><li><code>A</code> – interval matrix</li><li><code>t</code> – non-negative time value</li><li><code>p</code> – order of the Taylor approximation</li></ul><p><strong>Output</strong></p><p>An interval matrix representing the correction matrix.</p><p><strong>Algorithm</strong></p><p>See Proposition 3.4 in [1].</p><p>[1] M. Althoff. Reachability analysis and its application to the safety assessment of automonous cars. 2010.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/306b3527c8781ef534428eb53121cff47242a0df/src/correction_matrices.jl#L30-L53">source</a></section><h2><a class="nav-anchor" id="Norms-1" href="#Norms-1">Norms</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.opnorm" href="#LinearAlgebra.opnorm"><code>LinearAlgebra.opnorm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">opnorm(A::IntervalMatrix, p::Real=Inf)</code></pre><p>The matrix norm of an interval matrix.</p><p><strong>Input</strong></p><ul><li><code>A</code> – interval matrix</li><li><code>p</code> – (optional, default: <code>Inf</code>) the class of <code>p</code>-norm</li></ul><p><strong>Notes</strong></p><p>The matrix <span>$p$</span>-norm of an interval matrix <span>$A$</span> is defined as</p><div>\[    ‖A‖_p := ‖\max(|\text{inf}(A)|, |\text{sup}(A)|)‖_p\]</div><p>where <span>$\max$</span> and <span>$|·|$</span> are taken elementwise.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/306b3527c8781ef534428eb53121cff47242a0df/src/matrix.jl#L149-L168">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalMatrices.diam_norm" href="#IntervalMatrices.diam_norm"><code>IntervalMatrices.diam_norm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">diam_norm(A::IntervalMatrix, p=Inf)</code></pre><p>Return the diameter norm of the interval matrix.</p><p><strong>Input</strong></p><ul><li><code>A</code> – interval matrix</li><li><code>p</code> – (optional, default: <code>Inf</code>) the <code>p</code>-norm used; valid options are:        <code>1</code>, <code>2</code>, <code>Inf</code></li></ul><p><strong>Output</strong></p><p>The operator norm, in the <code>p</code>-norm, of the scalar matrix obtained by taking the element-wise <code>diam</code> function, where <code>diam(x) := sup(x) - inf(x)</code> for an interval <code>x</code>.</p><p><strong>Notes</strong></p><p>This function gives a measure of the <em>width</em> of the interval matrix.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/306b3527c8781ef534428eb53121cff47242a0df/src/matrix.jl#L529-L549">source</a></section><footer><hr/><a class="previous" href="../types/"><span class="direction">Previous</span><span class="title">Types</span></a><a class="next" href="../../about/"><span class="direction">Next</span><span class="title">About</span></a></footer></article></body></html>
