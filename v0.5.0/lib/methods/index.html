<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Methods · IntervalMatrices.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/juliareach.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>IntervalMatrices.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="../types/">Types</a></li><li class="current"><a class="toctext" href>Methods</a><ul class="internal"><li><a class="toctext" href="#Common-functions-1">Common functions</a></li><li><a class="toctext" href="#Exponentiation-1">Exponentiation</a></li><li><a class="toctext" href="#Finite-expansions-1">Finite expansions</a></li><li><a class="toctext" href="#Correction-terms-1">Correction terms</a></li><li><a class="toctext" href="#Norms-1">Norms</a></li></ul></li></ul></li><li><a class="toctext" href="../../about/">About</a></li></ul></nav><article id="docs"><header><nav><ul><li>Library</li><li><a href>Methods</a></li></ul><a class="edit-page" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/master/docs/src/lib/methods.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Methods</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Methods-1" href="#Methods-1">Methods</a></h1><p>This section describes systems methods implemented in <code>IntervalMatrices.jl</code>.</p><ul><li><a href="#Methods-1">Methods</a></li><ul><li><a href="#Common-functions-1">Common functions</a></li><li><a href="#Exponentiation-1">Exponentiation</a></li><li><a href="#Finite-expansions-1">Finite expansions</a></li><li><a href="#Correction-terms-1">Correction terms</a></li><li><a href="#Norms-1">Norms</a></li></ul></ul><h2><a class="nav-anchor" id="Common-functions-1" href="#Common-functions-1">Common functions</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalArithmetic.inf" href="#IntervalArithmetic.inf"><code>IntervalArithmetic.inf</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">inf(A::IntervalMatrix{T}) where {T}</code></pre><p>Return the infimum of an interval matrix <code>A</code>, which corresponds to taking the element-wise infimum of <code>A</code>.</p><p><strong>Input</strong></p><ul><li><code>A</code> – interval matrix</li></ul><p><strong>Output</strong></p><p>A scalar matrix whose coefficients are the infima of each element in <code>A</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/3ce3b33f559e6bff269e176356977f2ecc6c34b9/src/matrix.jl#L169-L182">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalArithmetic.sup" href="#IntervalArithmetic.sup"><code>IntervalArithmetic.sup</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">sup(A::IntervalMatrix{T}) where {T}</code></pre><p>Return the supremum of an interval matrix <code>A</code>, which corresponds to taking the element-wise supremum of <code>A</code>.</p><p><strong>Input</strong></p><ul><li><code>A</code> – interval matrix</li></ul><p><strong>Output</strong></p><p>A scalar matrix whose coefficients are the suprema of each element in <code>A</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/3ce3b33f559e6bff269e176356977f2ecc6c34b9/src/matrix.jl#L187-L200">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalArithmetic.mid" href="#IntervalArithmetic.mid"><code>IntervalArithmetic.mid</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">mid(A::IntervalMatrix{T}) where {T}</code></pre><p>Return the midpoint of an interval matrix <code>A</code>, which corresponds to taking the element-wise midpoint of <code>A</code>.</p><p><strong>Input</strong></p><ul><li><code>A</code> – interval matrix</li></ul><p><strong>Output</strong></p><p>A scalar matrix whose coefficients are the midpoints of each element in <code>A</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/3ce3b33f559e6bff269e176356977f2ecc6c34b9/src/matrix.jl#L205-L218">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalArithmetic.diam" href="#IntervalArithmetic.diam"><code>IntervalArithmetic.diam</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">diam(A::IntervalMatrix{T}) where {T}</code></pre><p>Return a matrix whose entries describe the diameters of the intervals.</p><p><strong>Input</strong></p><ul><li><code>A</code> – interval matrix</li></ul><p><strong>Output</strong></p><p>A matrix <code>B</code> of the same shape as <code>A</code> such that <code>B[i, j] == diam(A[i, j])</code> for each <code>i</code> and <code>j</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/3ce3b33f559e6bff269e176356977f2ecc6c34b9/src/matrix.jl#L365-L378">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.rand" href="#Base.rand"><code>Base.rand</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">rand(::Type{IntervalMatrix}, m::Int=2, [n]::Int=m;
     N=Float64, rng::AbstractRNG=GLOBAL_RNG)</code></pre><p>Return a random interval matrix of the given size and numeric type.</p><p><strong>Input</strong></p><ul><li><code>IntervalMatrix</code> – type, used for dispatch</li><li><code>m</code>              – (optional, default: <code>2</code>) number of rows</li><li><code>n</code>              – (optional, default: <code>m</code>) number of columns</li><li><code>rng</code>            – (optional, default: <code>GLOBAL_RNG</code>) random-number generator</li></ul><p><strong>Output</strong></p><p>An interval matrix of size <span>$m × n$</span> whose coefficients are normally-distributed intervals of type <code>N</code> with mean <code>0</code> and standard deviation <code>1</code>.</p><p><strong>Notes</strong></p><p>If this function is called with only one argument, it creates a square matrix, because the number of columns defaults to the number of rows.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/3ce3b33f559e6bff269e176356977f2ecc6c34b9/src/matrix.jl#L302-L324">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalMatrices.sample" href="#IntervalMatrices.sample"><code>IntervalMatrices.sample</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">sample(A::IntervalMatrix{T}; rng::AbstractRNG=GLOBAL_RNG) where {T}</code></pre><p>Return a sample of the given random interval matrix.</p><p><strong>Input</strong></p><ul><li><code>A</code>   – interval matrix</li><li><code>m</code>   – (optional, default: <code>2</code>) number of rows</li><li><code>n</code>   – (optional, default: <code>2</code>) number of columns</li><li><code>rng</code> – (optional, default: <code>GLOBAL_RNG</code>) random-number generator</li></ul><p><strong>Output</strong></p><p>An interval matrix of size <span>$m × n$</span> whose coefficients are normally-distributed intervals of type <code>N</code> with mean <code>0</code> and standard deviation <code>1</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/3ce3b33f559e6bff269e176356977f2ecc6c34b9/src/matrix.jl#L336-L352">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.split" href="#Base.split"><code>Base.split</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">split(A::IntervalMatrix{T}) where {T}</code></pre><p>Split an interval matrix <span>$A$</span> into two scalar matrices <span>$C$</span> and <span>$S$</span> such that <span>$A = C + [-S, S]$</span>.</p><p><strong>Input</strong></p><ul><li><code>A</code> – interval matrix</li></ul><p><strong>Output</strong></p><p>A pair <code>(C, S)</code> such that the entries of <code>C</code> are the central points and the entries of <code>S</code> are the (nonnegative) radii of the intervals in <code>A</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/3ce3b33f559e6bff269e176356977f2ecc6c34b9/src/matrix.jl#L223-L237">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:∈" href="#Base.:∈"><code>Base.:∈</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">∈(M::AbstractMatrix, A::AbstractIntervalMatrix)</code></pre><p>Check whether a concrete matrix is an instance of an interval matrix.</p><p><strong>Input</strong></p><ul><li><code>M</code> – concrete matrix</li><li><code>A</code> – interval matrix</li></ul><p><strong>Output</strong></p><p><code>true</code> iff <code>M</code> is an instance of <code>A</code></p><p><strong>Algorithm</strong></p><p>We check for each entry in <code>M</code> whether it belongs to the corresponding interval in <code>A</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/3ce3b33f559e6bff269e176356977f2ecc6c34b9/src/matrix.jl#L255-L273">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalMatrices.square" href="#IntervalMatrices.square"><code>IntervalMatrices.square</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">square(A::IntervalMatrix)</code></pre><p>Compute the square of an interval matrix.</p><p><strong>Input</strong></p><ul><li><code>A</code> – interval matrix</li></ul><p><strong>Output</strong></p><p>An interval matrix equivalent to <code>A * A</code>.</p><p><strong>Algorithm</strong></p><p>We follow [1, Section 6].</p><p>[1] Kosheleva, Kreinovich, Mayer, Nguyen. Computing the cube of an interval matrix is NP-hard. SAC 2005.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/3ce3b33f559e6bff269e176356977f2ecc6c34b9/src/arithmetic.jl#L40-L59">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalMatrices.scale" href="#IntervalMatrices.scale"><code>IntervalMatrices.scale</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">scale(A::IntervalMatrix{T}, α::T) where {T}</code></pre><p>Return a new interval matrix whose entries are scaled by the given factor.</p><p><strong>Input</strong></p><ul><li><code>A</code> – interval matrix</li><li><code>α</code> – scaling factor</li></ul><p><strong>Output</strong></p><p>A new matrix <code>B</code> of the same shape as <code>A</code> such that <code>B[i, j] = α*A[i, j]</code> for each <code>i</code> and <code>j</code>.</p><p><strong>Notes</strong></p><p>See <code>scale!</code> for the in-place version of this function.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/3ce3b33f559e6bff269e176356977f2ecc6c34b9/src/matrix.jl#L383-L401">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalMatrices.scale!" href="#IntervalMatrices.scale!"><code>IntervalMatrices.scale!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">scale(A::IntervalMatrix{T}, α::T) where {T}</code></pre><p>Modifies the given interval matrix, scaling its entries by the given factor.</p><p><strong>Input</strong></p><ul><li><code>A</code> – interval matrix</li><li><code>α</code> – scaling factor</li></ul><p><strong>Output</strong></p><p>The matrix <code>A</code> such that for each <code>i</code> and <code>j</code>, the new value of <code>A[i, j]</code> is <code>α*A[i, j]</code>.</p><p><strong>Notes</strong></p><p>This is the in-place version of <code>scale</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/3ce3b33f559e6bff269e176356977f2ecc6c34b9/src/matrix.jl#L406-L424">source</a></section><h2><a class="nav-anchor" id="Exponentiation-1" href="#Exponentiation-1">Exponentiation</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalMatrices.exp_overapproximation" href="#IntervalMatrices.exp_overapproximation"><code>IntervalMatrices.exp_overapproximation</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">exp_overapproximation(M::IntervalMatrix{T, Interval{T}}, t, p) where {T}</code></pre><p>Overapproximation of the exponential of an interval matrix.</p><p><strong>Input</strong></p><ul><li><code>A</code> – interval matrix</li><li><code>t</code> – non-negative time value</li><li><code>p</code> – order of the approximation</li></ul><p><strong>Algorithm</strong></p><p>See Theorem 1 in <em>Reachability Analysis of Linear Systems with Uncertain Parameters and Inputs</em> by M. Althoff, O. Stursberg, M. Buss.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/3ce3b33f559e6bff269e176356977f2ecc6c34b9/src/exponential.jl#L124-L139">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalMatrices.exp_underapproximation" href="#IntervalMatrices.exp_underapproximation"><code>IntervalMatrices.exp_underapproximation</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">exp_underapproximation(M::IntervalMatrix{T, Interval{T}}, t, p) where {T}</code></pre><p>Overapproximation of the exponential of an interval matrix.</p><p><strong>Input</strong></p><ul><li><code>A</code> – interval matrix</li><li><code>t</code> – non-negative time value</li><li><code>p</code> – order of the approximation</li></ul><p><strong>Algorithm</strong></p><p>See Theorem 2 in <em>Reachability Analysis of Linear Systems with Uncertain Parameters and Inputs</em> by M. Althoff, O. Stursberg, M. Buss.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/3ce3b33f559e6bff269e176356977f2ecc6c34b9/src/exponential.jl#L202-L217">source</a></section><h2><a class="nav-anchor" id="Finite-expansions-1" href="#Finite-expansions-1">Finite expansions</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalMatrices.quadratic_expansion" href="#IntervalMatrices.quadratic_expansion"><code>IntervalMatrices.quadratic_expansion</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">quadratic_expansion(A::IntervalMatrix, t)</code></pre><p>Exactly compute the quadratic formula <span>$At + \frac{1}{2}A^2t^2$</span> using interval arithmetics.</p><p><strong>Input</strong></p><ul><li><code>A</code> – interval matrix</li><li><code>t</code> – non-negative time value</li></ul><p><strong>Algorithm</strong></p><p>See Lemma 1 in <em>Reachability Analysis of Linear Systems with Uncertain Parameters and Inputs</em> by M. Althoff, O. Stursberg, M. Buss.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/3ce3b33f559e6bff269e176356977f2ecc6c34b9/src/exponential.jl#L3-L18">source</a><div><div><pre><code class="language-none">quadratic_expansion(A::IntervalMatrix, α::Real, β::Real)</code></pre><p>Compute the quadratic expansion of an interval matrix, <span>$αA + βA^2$</span>, using interval arithmetics.</p><p><strong>Input</strong></p><ul><li><code>A</code> – interval matrix</li><li><code>α</code> – linear coefficient</li><li><code>β</code> – quadratic coefficient</li></ul><p><strong>Output</strong></p><p>An interval matrix that encloses <span>$B := αA + βA^2$</span>.</p><p><strong>Algorithm</strong></p><p>This a variation of the algorithm in [1, Section 6]. If <span>$A = (aᵢⱼ)$</span> and <span>$B := αA + βA^2 = (bᵢⱼ)$</span>, the idea is to compute each <span>$bᵢⱼ$</span> by factoring out repeated expressions (thus the term <em>single-use expressions</em>).</p><p>First, let <span>$i = j$</span>. In this case,</p><div>\[bⱼⱼ = β\sum_\{k, k ≠ j} a_{jk} a_{kj} + (α + βa_{jj}) a_{jj}.\]</div><p>Now consider <span>$i ≠ j$</span>. Then,</p><div>\[bᵢⱼ = β\sum_\{k, k ≠ i, k ≠ j} a_{ik} a_{kj} + (α + βa_{ii} + βa_{jj}) a_{ij}.\]</div><p>[1] Kosheleva, Kreinovich, Mayer, Nguyen. Computing the cube of an interval matrix is NP-hard. SAC 2005.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/3ce3b33f559e6bff269e176356977f2ecc6c34b9/src/exponential.jl#L60-L96">source</a></section><h2><a class="nav-anchor" id="Correction-terms-1" href="#Correction-terms-1">Correction terms</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalMatrices.correction_hull" href="#IntervalMatrices.correction_hull"><code>IntervalMatrices.correction_hull</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">correction_hull(A::IntervalMatrix{T}, t, p) where {T}</code></pre><p>Compute the correction term for the convex hull of a point and its linear map with an interval matrix in order to contain all trajectories of a linear system.</p><p><strong>Input</strong></p><ul><li><code>A</code> – interval matrix</li><li><code>t</code> – non-negative time value</li><li><code>p</code> – order of the approximation</li></ul><p><strong>Output</strong></p><p>An interval matrix representing the correction term.</p><p><strong>Algorithm</strong></p><p>See Theorem 3 in [1].</p><p>[1] M. Althoff, O. Stursberg, M. Buss. Reachability Analysis of Linear Systems with Uncertain Parameters and Inputs. CDC 2007.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/3ce3b33f559e6bff269e176356977f2ecc6c34b9/src/correction_matrices.jl#L1-L23">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="IntervalMatrices.input_correction" href="#IntervalMatrices.input_correction"><code>IntervalMatrices.input_correction</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">input_correction(A::IntervalMatrix{T}, t, p) where {T}</code></pre><p>Compute the <em>input correction matrix</em> for discretizing an inhomogeneous affine dynamical system with an interval matrix and an input domain not containing the origin.</p><p><strong>Input</strong></p><ul><li><code>A</code> – interval matrix</li><li><code>t</code> – non-negative time value</li><li><code>p</code> – order of the Taylor approximation</li></ul><p><strong>Output</strong></p><p>An interval matrix representing the correction matrix.</p><p><strong>Algorithm</strong></p><p>See Proposition 3.4 in [1].</p><p>[1] M. Althoff. Reachability analysis and its application to the safety assessment of automonous cars. 2010.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/3ce3b33f559e6bff269e176356977f2ecc6c34b9/src/correction_matrices.jl#L30-L53">source</a></section><h2><a class="nav-anchor" id="Norms-1" href="#Norms-1">Norms</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.opnorm" href="#LinearAlgebra.opnorm"><code>LinearAlgebra.opnorm</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">opnorm(A::IntervalMatrix, p::Real=Inf)</code></pre><p>The matrix norm of an interval matrix.</p><p><strong>Input</strong></p><ul><li><code>A</code> – interval matrix</li><li><code>p</code> – (optional, default: <code>Inf</code>) the class of <code>p</code>-norm</li></ul><p><strong>Notes</strong></p><p>The matrix <span>$p$</span>-norm of an interval matrix <span>$A$</span> is defined as</p><div>\[    ‖A‖_p := ‖\max(|\text{inf}(A)|, |\text{sup}(A)|)‖_p\]</div><p>where <span>$\max$</span> and <span>$|·|$</span> are taken elementwise.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/IntervalMatrices.jl/blob/3ce3b33f559e6bff269e176356977f2ecc6c34b9/src/matrix.jl#L141-L160">source</a></section><footer><hr/><a class="previous" href="../types/"><span class="direction">Previous</span><span class="title">Types</span></a><a class="next" href="../../about/"><span class="direction">Next</span><span class="title">About</span></a></footer></article></body></html>
